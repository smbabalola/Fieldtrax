Next Feature: Fix onUpdate Function in CustomerInfoTab

Files Needed for Next Phase:

1. Current Implementation Files:

   ```

   /src/pages/job/CreateJobPage.jsx  (Parent component that provides onUpdate)
// src/pages/job/CreateJobPage.jsx
import React, { useState, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { Card, Alert, Row, Col, Nav, Tab } from 'react-bootstrap';
import { 
  createJob, 
  selectJobsLoading, 
  selectJobsError,
  fetchRelatedData
} from '../../store/slices/jobsSlice';
import NavigationButtons from '../../components/common/NavigationButtons';
import CustomerInfoTab from "../../components/jobs/CreateJob/tabs/CustomerInfoTab";
import WellInfoTab from '../../components/jobs/CreateJob/tabs/WellInfoTab';
import RigInfoTab from '../../components/jobs/CreateJob/tabs/RigInfoTab';
import WellboreGeometryTab from '../../components/jobs/CreateJob/tabs/WellboreGeometryTab';
import TrajectoryTab from '../../components/jobs/CreateJob/tabs/TrajectoryTab';
import FluidsTab from '../../components/jobs/CreateJob/tabs/FluidsTab';

const INITIAL_FORM_DATA = {
  operator_id: '',
  contract_id: '',
  po_number: '',
  po_amount: '',
  po_start_date: '',
  po_end_date: '',
  well_id: '',
  field_name: '',
  well_type: '',
  well_status: '',
  spud_date: '',
  total_depth_planned: '',
  rig_id: '',
  rig_type: '',
  rig_capability: '',
  rig_status: '',
};

const TABS = [
  {
    id: 'customer-info',
    title: 'Customer Information',
    component: CustomerInfoTab,
    requiredFields: ['operator_id', 'contract_id', 'po_number']
  },
  {
    id: 'well-info',
    title: 'Well Information',
    component: WellInfoTab,
    requiredFields: ['well_id', 'field_name', 'well_type']
  },
  {
    id: 'rig-info',
    title: 'Rig Information',
    component: RigInfoTab,
    requiredFields: ['rig_id', 'rig_type']
  },
  {
    id: 'wellbore-geometry',
    title: 'Wellbore Geometry',
    component: WellboreGeometryTab,
    requiredFields: ['wellbore_type', 'total_depth']
  },
  {
    id: 'trajectory',
    title: 'Trajectory',
    component: TrajectoryTab,
    requiredFields: ['trajectory_type']
  },
  {
    id: 'fluids',
    title: 'Fluids',
    component: FluidsTab,
    requiredFields: ['primary_fluid_type']
  }
];

const CreateJobPage = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(TABS[0].id);
  const [formData, setFormData] = useState(INITIAL_FORM_DATA);
  const [formErrors, setFormErrors] = useState({});
  const [error, setError] = useState(null);

  const isLoading = useSelector(selectJobsLoading);
  const apiError = useSelector(selectJobsError);

  // Check if current tab is valid
  const isTabValid = useCallback((tabId) => {
    const tab = TABS.find(t => t.id === tabId);
    if (!tab) return false;

    return tab.requiredFields.every(field => {
      const value = formData[field];
      return value !== undefined && value !== null && value !== '';
    });
  }, [formData]);

  // Check if all previous tabs are valid
  const arePreviousTabsValid = useCallback((currentTabId) => {
    const currentIndex = TABS.findIndex(tab => tab.id === currentTabId);
    return TABS.slice(0, currentIndex).every(tab => isTabValid(tab.id));
  }, [isTabValid]);

  // Handle tab change
  const handleTabChange = useCallback((tabId) => {
    if (arePreviousTabsValid(tabId)) {
      setActiveTab(tabId);
      setError(null);
    } else {
      setError('Please complete all required fields in previous tabs before proceeding.');
    }
  }, [arePreviousTabsValid]);

  // Handle form data changes
  const handleFormChange = useCallback((data) => {
    setFormData(data);
  }, []);

  // Navigation handlers
  const handlePrevious = useCallback(() => {
    const currentIndex = TABS.findIndex(tab => tab.id === activeTab);
    if (currentIndex > 0) {
      setActiveTab(TABS[currentIndex - 1].id);
      setError(null);
    }
  }, [activeTab]);

  const handleNext = useCallback(() => {
    const currentIndex = TABS.findIndex(tab => tab.id === activeTab);
    if (currentIndex < TABS.length - 1 && isTabValid(activeTab)) {
      setActiveTab(TABS[currentIndex + 1].id);
      setError(null);
    } else {
      setError('Please complete all required fields in the current tab before proceeding.');
    }
  }, [activeTab, isTabValid]);

  // Save handler
  const handleSave = useCallback(async () => {
    if (!TABS.every(tab => isTabValid(tab.id))) {
      setError('Please complete all required fields before saving.');
      return;
    }

    try {
      const result = await dispatch(createJob(formData)).unwrap();
      navigate(`/jobs/${result.id}`);
    } catch (err) {
      setError(err.message || 'Failed to create job');
    }
  }, [dispatch, formData, isTabValid, navigate]);

  // Render current tab component
  const renderTabContent = useCallback(() => {
    const CurrentTab = TABS.find(tab => tab.id === activeTab)?.component;
    if (!CurrentTab) return null;

    return (
      <CurrentTab
        data={formData}
        errors={formErrors}
        onChange={handleFormChange}
      />
    );
  }, [activeTab, formData, formErrors, handleFormChange]);

  return (
    <div className="p-4">
      <Card>
        <Card.Header>
          <h4 className="mb-0">Create New Job</h4>
        </Card.Header>
        <Card.Body>
          {(error || apiError) && (
            <Alert variant="danger" onClose={() => setError(null)} dismissible>
              {error || apiError}
            </Alert>
          )}

          <Tab.Container activeKey={activeTab}>
            <Row>
              <Col md={3}>
                <Nav variant="pills" className="flex-column">
                  {TABS.map((tab) => (
                    <Nav.Item key={tab.id}>
                      <Nav.Link
                        eventKey={tab.id}
                        onClick={() => handleTabChange(tab.id)}
                        className="d-flex align-items-center"
                      >
                        {tab.title}
                        {isTabValid(tab.id) && (
                          <i className="bi bi-check-circle-fill text-success ms-2"></i>
                        )}
                      </Nav.Link>
                    </Nav.Item>
                  ))}
                </Nav>
              </Col>
              <Col md={9}>
                <Tab.Content>
                  <Tab.Pane eventKey={activeTab}>
                    {renderTabContent()}
                  </Tab.Pane>
                </Tab.Content>

                <div className="mt-4 border-top pt-3">
                  <NavigationButtons
                    onPrevious={handlePrevious}
                    onNext={handleNext}
                    onSave={handleSave}
                    canGoNext={isTabValid(activeTab)}
                    canGoPrevious={TABS.findIndex(tab => tab.id === activeTab) > 0}
                    canSave={TABS.every(tab => isTabValid(tab.id))}
                    isLastStep={activeTab === TABS[TABS.length - 1].id}
                    isLoading={isLoading}
                  />
                </div>
              </Col>
            </Row>
          </Tab.Container>
        </Card.Body>
      </Card>
    </div>
  );
};

export default CreateJobPage;
   /src/store/slices/jobsSlice.js    (Redux state management)
// jobsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import jobService from '../../services/jobService';

// Async Thunks
export const fetchJobs = createAsyncThunk(
  'jobs/fetchJobs',
  async (params, { rejectWithValue }) => {
    try {
      const response = await jobService.getJobs(params);
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchJobDetails = createAsyncThunk(
  'jobs/fetchJobDetails',
  async (jobId, { rejectWithValue }) => {
    try {
      const response = await jobService.getJob(jobId);
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const createJob = createAsyncThunk(
  'jobs/createJob',
  async (jobData, { rejectWithValue }) => {
    try {
      const response = await jobService.createJob(jobData);
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateJob = createAsyncThunk(
  'jobs/updateJob',
  async ({ id, data }, { rejectWithValue }) => {
    try {
      const response = await jobService.updateJob(id, data);
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const deleteJob = createAsyncThunk(
  'jobs/deleteJob',
  async (jobId, { rejectWithValue }) => {
    try {
      await jobService.deleteJob(jobId);
      return jobId;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateJobStatus = createAsyncThunk(
  'jobs/updateJobStatus',
  async ({ jobId, status }, { rejectWithValue }) => {
    try {
      const response = await jobService.updateJobStatus(jobId, status);
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchRelatedData = createAsyncThunk(
  'jobs/fetchRelatedData',
  async (_, { rejectWithValue }) => {
    try {
      const [rigs, wells, operators, purchaseOrders] = await Promise.all([
        jobService.fetchRigs(),
        jobService.fetchWells(),
        jobService.fetchOperators(),
        jobService.fetchPurchaseOrders()
      ]);
      
      return {
        rigs: rigs.data,
        wells: wells.data,
        operators: operators.data,
        purchaseOrders: purchaseOrders.data
      };
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const initialFilters = {
  status: 'ALL',
  priority: 'ALL',
  searchTerm: '',
  dateRange: {
    startDate: null,
    endDate: null
  }
};

// Initial State
const initialState = {
  jobs: [],
  selectedJob: null,
  pagination: {
    currentPage: 1,
    pageSize: 10,
    totalItems: 0,
    totalPages: 0
  },
  loading: false,
  jobDetailsLoading: false,
  error: null,
  jobDetailsError: null,
  relatedData: {
    rigs: [],
    wells: [],
    operators: [],
    purchaseOrders: [],
    loading: false,
    error: null
  },
  filters: {
    status: 'ALL',
    priority: 'ALL',
    searchTerm: '',
    dateRange: {
      startDate: null,
      endDate: null
    }
  },
  sorting: {
    field: 'created_at',
    direction: 'desc'
  }
};

// Slice
const jobsSlice = createSlice({
  name: 'jobs',
  initialState,
  reducers: {
    clearJobDetails: (state) => {
      state.selectedJob = null;
      state.jobDetailsError = null;
    },
    setFilter: (state, action) => {
      state.filters = {
        ...state.filters,
        ...action.payload
      };
    },
    resetFilters: (state) => {
      state.filters = initialFilters;
    },
    setSorting: (state, action) => {
      state.sorting = action.payload;
    },
    setPagination: (state, action) => {
      state.pagination = {
        ...state.pagination,
        ...action.payload
      };
    }, 
    setPage: (state, action) => {
      state.pagination.currentPage = action.payload;
    },
    setPageSize: (state, action) => {
      state.pagination.pageSize = action.payload;
      state.pagination.currentPage = 1;
    },
    clearErrors: (state) => {
      state.error = null;
      state.jobDetailsError = null;
      state.relatedData.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch Jobs
      .addCase(fetchJobs.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchJobs.fulfilled, (state, action) => {
        state.loading = false;
        state.jobs = action.payload.items;
        state.pagination = {
          currentPage: action.payload.page,
          pageSize: action.payload.page_size,
          totalItems: action.payload.total,
          totalPages: action.payload.total_pages
        };
      })
      .addCase(fetchJobs.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch Job Details
      .addCase(fetchJobDetails.pending, (state) => {
        state.jobDetailsLoading = true;
        state.jobDetailsError = null;
      })
      .addCase(fetchJobDetails.fulfilled, (state, action) => {
        state.jobDetailsLoading = false;
        state.selectedJob = action.payload;
      })
      .addCase(fetchJobDetails.rejected, (state, action) => {
        state.jobDetailsLoading = false;
        state.jobDetailsError = action.payload;
      })

      // Create Job
      .addCase(createJob.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createJob.fulfilled, (state, action) => {
        state.loading = false;
        state.jobs.unshift(action.payload);
        // Update total items count
        state.pagination.totalItems += 1;
      })
      .addCase(createJob.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Update Job
      .addCase(updateJob.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateJob.fulfilled, (state, action) => {
        state.loading = false;
        const index = state.jobs.findIndex(job => job.id === action.payload.id);
        if (index !== -1) {
          state.jobs[index] = action.payload;
        }
        // Update selected job if it's the one being updated
        if (state.selectedJob?.id === action.payload.id) {
          state.selectedJob = action.payload;
        }
      })
      .addCase(updateJob.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Delete Job
      .addCase(deleteJob.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteJob.fulfilled, (state, action) => {
        state.loading = false;
        state.jobs = state.jobs.filter(job => job.id !== action.payload);
        if (state.selectedJob?.id === action.payload) {
          state.selectedJob = null;
        }
        // Update total items count
        state.pagination.totalItems -= 1;
      })
      .addCase(deleteJob.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Update Job Status
      .addCase(updateJobStatus.fulfilled, (state, action) => {
        const index = state.jobs.findIndex(job => job.id === action.payload.id);
        if (index !== -1) {
          state.jobs[index] = action.payload;
        }
        if (state.selectedJob?.id === action.payload.id) {
          state.selectedJob = action.payload;
        }
      })

      // Fetch Related Data
      .addCase(fetchRelatedData.pending, (state) => {
        state.relatedData.loading = true;
        state.relatedData.error = null;
      })
      .addCase(fetchRelatedData.fulfilled, (state, action) => {
        state.relatedData = {
          ...state.relatedData,
          ...action.payload,
          loading: false,
          error: null
        };
      })
      .addCase(fetchRelatedData.rejected, (state, action) => {
        state.relatedData.loading = false;
        state.relatedData.error = action.payload;
      });
  }
});

// Action Creators
export const {
  clearJobDetails,
  setFilter,
  setFilters,
  resetFilters,
  setSorting,
  setPagination,
  setPage,
  setPageSize,
  clearErrors
} = jobsSlice.actions;

// Selectors
export const selectJobs = state => state.jobs.jobs;
export const selectSelectedJob = state => state.jobs.selectedJob;
export const selectJobDetailsLoading = state => state.jobs.jobDetailsLoading;
export const selectJobDetailsError = state => state.jobs.jobDetailsError;
export const selectLoading = state => state.jobs.loading;
export const selectJobsLoading = state => state.jobs.loading; 
export const selectError = state => state.jobs.error;
export const selectJobsError = state => state.jobs.error;
export const selectFilters = state => state.jobs.filters;
export const selectPagination = state => state.jobs.pagination;
export const selectJobsPagination = state => state.jobs.pagination; 
export const selectJobsFilters = state => state.jobs.filters;
export const selectSorting = state => state.jobs.sorting;
export const selectJobsSorting = state => state.jobs.sorting; 
export const selectRelatedData = state => state.jobs.relatedData;

// Complex selectors
export const selectFilteredJobs = state => {
  const jobs = selectJobs(state);
  const filters = selectJobsFilters(state);
  
  return jobs.filter(job => {
    const matchesStatus = filters.status === 'ALL' || job.status === filters.status;
    const matchesPriority = filters.priority === 'ALL' || job.priority === filters.priority;
    const matchesSearch = !filters.searchTerm || 
      job.description?.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
      job.job_number?.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
      job.notes?.toLowerCase().includes(filters.searchTerm.toLowerCase());
    
    const matchesDateRange = !filters.dateRange.startDate || !filters.dateRange.endDate || 
      (new Date(job.start_date) >= new Date(filters.dateRange.startDate) &&
       new Date(job.start_date) <= new Date(filters.dateRange.endDate));

    return matchesStatus && matchesPriority && matchesSearch && matchesDateRange;
  });
};

export const selectJobById = (state, jobId) => 
  state.jobs.jobs.find(job => job.id === jobId);

export default jobsSlice.reducer;

   /src/components/jobs/CreateJob/tabs/CustomerInfoTab.jsx (Current implementation)
// src/components/jobs/CreateJob/tabs/CustomerInfoTab.jsx
import React, { useState, useEffect } from 'react';
import { toast } from 'react-toastify';
import { Form, Row, Col, Card, Button, Alert } from 'react-bootstrap';
import { DataTable } from '../../../common/DataTable';
import operatorService from '../../../../services/operatorService';
import purchaseOrderService from '../../../../services/purchaseOrderService';
import OperatorDetailModal from '../../../operators/OperatorDetailModal';
import PurchaseOrderModal from '../../../purchaseOrders/PurchaseOrderModal';

const CustomerInfoTab = ({ data, onUpdate, errors = {}, isUpdateMode = false }) => {
  // State Management
  const [loading, setLoading] = useState(false);
  const [operators, setOperators] = useState([]);
  const [purchaseOrders, setPurchaseOrders] = useState([]);
  const [showOperatorModal, setShowOperatorModal] = useState(false);
  const [showPOModal, setShowPOModal] = useState(false);
  const [selectedOperator, setSelectedOperator] = useState(null);
  const [sortField, setSortField] = useState('operator_name');
  const [sortDirection, setSortDirection] = useState('asc');
  const [error, setError] = useState(null);
  const [pagination, setPagination] = useState({
    currentPage: 1,
    totalPages: 1,
    pageSize: 10,
    totalItems: 0
  });

  // Table Columns
  const columns = [
    { field: 'operator_name', header: 'Operator Name', sortable: true },
    { field: 'company_code', header: 'Company Code', sortable: true },
    { field: 'account', header: 'Account', sortable: true },
    { field: 'country', header: 'Country', sortable: true }
  ];

  // Fetch Operators
  useEffect(() => {
    const fetchOperators = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await operatorService.getOperators({
          page: pagination.currentPage - 1,
          limit: pagination.pageSize,
          sort_field: sortField,
          sort_direction: sortDirection
        });

        console.log('Operators response:', response);

        if (Array.isArray(response?.items)) {
          setOperators(response.items);
          setPagination(prev => ({
            ...prev,
            totalPages: Math.ceil(response.total / prev.pageSize),
            totalItems: response.total
          }));
        } else if (Array.isArray(response)) {
          // Handle case where response is a direct array
          setOperators(response);
          setPagination(prev => ({
            ...prev,
            totalPages: Math.ceil(response.length / prev.pageSize),
            totalItems: response.length
          }));
        } else {
          console.error('Invalid operators response format:', response);
          setError('Invalid data format received from server');
        }
      } catch (err) {
        console.error('Error fetching operators:', err);
        setError(err.message || 'Failed to load operators');
        toast.error('Failed to load operators list');
      } finally {
        setLoading(false);
      }
    };

    fetchOperators();
  }, [pagination.currentPage, pagination.pageSize, sortField, sortDirection]);

  // Fetch Purchase Orders when operator changes
  useEffect(() => {
    const fetchPurchaseOrders = async () => {
      if (data.operator_id && isUpdateMode) {
        try {
          const response = await purchaseOrderService.getPurchaseOrders({
            operator_id: data.operator_id
          });
          setPurchaseOrders(Array.isArray(response) ? response : []);
        } catch (err) {
          console.error('Error fetching purchase orders:', err);
          toast.error('Failed to load purchase orders');
        }
      } else {
        setPurchaseOrders([]);
      }
    };

    fetchPurchaseOrders();
  }, [data.operator_id, isUpdateMode]);

  // Handlers
  const handleSort = (field) => {
    setSortDirection(prev => field === sortField && prev === 'asc' ? 'desc' : 'asc');
    setSortField(field);
  };

  const handleOperatorSelect = (operator) => {
    console.log('Selected operator:', operator);
    if (onUpdate) {
      onUpdate('operator', {
        operator_id: operator.id,
        country: operator.country
      });
    } else {
      console.warn('onUpdate function not provided to CustomerInfoTab');
    }
    setPurchaseOrders([]); // Clear purchase orders when operator changes
  };

  const handleOperatorAdded = (newOperator) => {
    setOperators(prev => [...prev, newOperator]);
    handleOperatorSelect(newOperator);
    setShowOperatorModal(false);
    toast.success('Operator added successfully');
  };

  const handlePageChange = (page) => {
    setPagination(prev => ({
      ...prev,
      currentPage: page
    }));
  };

  const handleAddPurchaseOrder = () => {
    if (!data.operator_id) {
      toast.error('Please select an operator first');
      return;
    }
    if (!isUpdateMode) {
      toast.info('Please save the job first before adding a purchase order');
      return;
    }
    setShowPOModal(true);
  };

  const handlePurchaseOrderCreated = (newPurchaseOrder) => {
    setPurchaseOrders(prev => [...prev, newPurchaseOrder]);
    if (onUpdate) {
      onUpdate('job', { purchase_order_id: newPurchaseOrder.id });
    }
    setShowPOModal(false);
    toast.success('Purchase order created successfully');
  };

  return (
    <div>
      {error && (
        <Alert variant="danger" onClose={() => setError(null)} dismissible>
          {error}
        </Alert>
      )}

      <Card className="mb-4">
        <Card.Body>
          <Row>
            <Col md={6}>
              <Form.Group>
                <Form.Label>Selected Operator <span className="text-danger">*</span></Form.Label>
                <div className="d-flex gap-2">
                  <Form.Control 
                    type="text"
                    value={operators.find(op => op.id === data.operator_id)?.operator_name || ''}
                    readOnly
                    placeholder="Select an operator from the table below"
                    isInvalid={!!errors.operator_id}
                  />
                  <Button 
                    variant="outline-primary"
                    onClick={() => {
                      setSelectedOperator(null);
                      setShowOperatorModal(true);
                    }}
                  >
                    Add New
                  </Button>
                </div>
                {errors.operator_id && (
                  <Form.Control.Feedback type="invalid">
                    {errors.operator_id}
                  </Form.Control.Feedback>
                )}
              </Form.Group>
            </Col>
          </Row>

          <Row className="mt-3">
            <Col md={4}>
              <Form.Group className="mb-3">
                <Form.Label>Service Code</Form.Label>
                <Form.Control
                  type="text"
                  value={data.service_code || ''}
                  onChange={(e) => onUpdate('job', { service_code: e.target.value })}
                  placeholder="Enter service code"
                />
              </Form.Group>
            </Col>
            <Col md={4}>
              <Form.Group className="mb-3">
                <Form.Label>Country</Form.Label>
                <Form.Control
                  type="text"
                  value={data.country || ''}
                  onChange={(e) => onUpdate('job', { country: e.target.value })}
                  placeholder="Enter country"
                />
              </Form.Group>
            </Col>
            <Col md={4}>
              <Form.Group className="mb-3">
                <Form.Label>Purchase Order</Form.Label>
                <div className="d-flex gap-2">
                  <Form.Select
                    value={data.purchase_order_id || ''}
                    onChange={(e) => onUpdate('job', { purchase_order_id: e.target.value })}
                    disabled={!isUpdateMode}
                  >
                    <option value="">Select Purchase Order</option>
                    {purchaseOrders.map(po => (
                      <option key={po.id} value={po.id}>
                        {po.po_number}
                      </option>
                    ))}
                  </Form.Select>
                  <Button
                    variant="outline-primary"
                    onClick={handleAddPurchaseOrder}
                    disabled={!isUpdateMode || !data.operator_id}
                  >
                    New PO
                  </Button>
                </div>
                {!isUpdateMode && (
                  <Form.Text className="text-muted">
                    Save the job first to add purchase orders
                  </Form.Text>
                )}
              </Form.Group>
            </Col>
          </Row>
        </Card.Body>
      </Card>

      <DataTable
        columns={columns}
        data={operators}
        loading={loading}
        onRowClick={handleOperatorSelect}
        sortField={sortField}
        sortDirection={sortDirection}
        onSort={handleSort}
        pagination={pagination}
        onPageChange={handlePageChange}
        selectedId={data.operator_id}
      />

      {/* Modals */}
      <OperatorDetailModal 
        show={showOperatorModal}
        onHide={() => setShowOperatorModal(false)}
        operator={selectedOperator}
        onOperatorAdded={handleOperatorAdded}
        onOperatorUpdated={handleOperatorAdded}
      />

      <PurchaseOrderModal
        show={showPOModal}
        onHide={() => setShowPOModal(false)}
        onPurchaseOrderCreated={handlePurchaseOrderCreated}
        wellId={data.well_id}
        operatorId={data.operator_id}
      />
    </div>
  );
};

export default CustomerInfoTab;
   /src/services/operatorService.js   (API service)
// src/services/operatorService.js
import api, { API_ENDPOINTS, handleApiError } from './api';

const operatorService = {
  getOperators: async (params = {}) => {
    try {
      console.log('Fetching operators with params:', params);
      const queryParams = {
        skip: params.page ? params.page * (params.limit || 10) : 0,
        limit: params.limit || 10,
        sort_field: params.sort_field || 'operator_name',
        sort_direction: params.sort_direction || 'asc'
      };

      const response = await api.get(API_ENDPOINTS.operators.getAll, { 
        params: queryParams 
      });

      // API returns data directly due to response interceptor
      console.log('Operators API response:', response);

      // Handle both paginated and non-paginated responses
      if (response?.items) {
        // Paginated response
        return {
          items: response.items,
          total: response.total,
          page: params.page || 0,
          pageSize: params.limit || 10
        };
      } else if (Array.isArray(response)) {
        // Non-paginated response
        return {
          items: response,
          total: response.length,
          page: params.page || 0,
          pageSize: params.limit || 10
        };
      }

      throw new Error('Invalid response format from server');
    } catch (error) {
      return handleApiError(error, 'Failed to fetch operators');
    }
  },

  getOperatorByName: async (name) => {
    try {
      const response = await api.get(API_ENDPOINTS.operators.getByName(name));
      return response;
    } catch (error) {
      return handleApiError(error, 'Failed to fetch operator by name');
    }
  },

  getOperatorByCode: async (code) => {
    try {
      const response = await api.get(API_ENDPOINTS.operators.getByCode(code));
      return response;
    } catch (error) {
      return handleApiError(error, 'Failed to fetch operator by code');
    }
  },

  createOperator: async (operatorData) => {
    try {
      const response = await api.post(API_ENDPOINTS.operators.create, operatorData);
      return response;
    } catch (error) {
      return handleApiError(error, 'Failed to create operator');
    }
  },

  updateOperator: async (id, operatorData) => {
    try {
      const response = await api.put(`${API_ENDPOINTS.operators.base}/${id}`, operatorData);
      return response;
    } catch (error) {
      return handleApiError(error, 'Failed to update operator');
    }
  },

  deleteOperator: async (id) => {
    try {
      const response = await api.delete(`${API_ENDPOINTS.operators.base}/${id}`);
      return response;
    } catch (error) {
      return handleApiError(error, 'Failed to delete operator');
    }
  }
};

export default operatorService;   

/src/services/api.js              (API configuration)

 // File: /src/services/api.js
import axios from 'axios';
import store from '../store';
import { logout } from '../store/slices/authSlice';
import { toast } from 'react-toastify';

// API Endpoints configuration
const API_ENDPOINTS = {
  auth: {
    login: '/token',
    refresh: '/token/refresh',
    logout: '/auth/logout'
  },
  fluids: {
    base: '/fluids',
    getByWellbore: (wellboreId) => `/fluids/wellbore/${wellboreId}`,
    getByType: (wellboreId, type) => `/fluids/wellbore/${wellboreId}/type/${type}`,
    update: (id) => `/fluids/${id}`
  },
  jobs: {
    base: '/jobs',
    getAll: '/jobs',
    getById: (id) => `/jobs/${id}`,
    create: '/jobs',
    update: (id) => `/jobs/${id}`,
    delete: (id) => `/jobs/${id}`,
    active: '/jobs/active',
    export: '/jobs/export'
  },
  operators: {
    base: '/operators',
    getAll: '/operators',
    getByName: (name) => `/operators/name/${name}`,
    getByCode: (code) => `/operators/code/${code}`,
    create: '/operators'
  },
  jobCenters: {
    base: '/job-centers',
    getAll: '/job-centers',
    getActive: '/job-centers/active',
    getByWell: (wellName) => `/job-centers/well/${wellName}`,
    getByShortName: (shortName) => `/job-centers/short/${shortName}`
  },
  wells: {
    base: '/wells',
    getAll: '/wells',
    getByOperator: (operatorId) => `/wells/operator/${operatorId}`,
    create: '/wells'
  },
  rigs: {
    base: '/rigs',
    getAll: '/rigs',
    getActive: '/rigs/active'
  },
  purchaseOrders: {
    base: '/purchase-orders',
    getAll: '/purchase-orders',
    getById: (id) => `/purchase-orders/${id}`
  }
};

// Create axios instance with default config
const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1',
  timeout: 10000,
  headers: {
    'Accept': 'application/json'
  },
  withCredentials: true
});

// Request interceptor
api.interceptors.request.use(
  (config) => {
    // Add CORS headers
    config.headers['Access-Control-Allow-Origin'] = 'http://localhost:3000';
    config.headers['Access-Control-Allow-Credentials'] = 'true';

    // Add auth token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    // Set Content-Type based on data type
    if (config.data instanceof URLSearchParams) {
      config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    } else if (typeof config.data === 'object') {
      config.headers['Content-Type'] = 'application/json';
    }

    // Clean up URL if it includes baseURL
    if (config.url.startsWith('/api/v1')) {
      config.url = config.url.substring(7);
    }

    return config;
  },
  (error) => {
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor
api.interceptors.response.use(
  (response) => {
    // Ensure we always have response.data
    if (!response.data) {
      console.warn('Empty response data received');
      return {};
    }
    return response.data;
  },
  async (error) => {
    const originalRequest = error.config;

    // Handle token expiration
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refreshToken');
        if (!refreshToken) {
          throw new Error('No refresh token available');
        }

        const response = await axios.post(
          `${api.defaults.baseURL}${API_ENDPOINTS.auth.refresh}`,
          { refresh_token: refreshToken }
        );

        const { access_token } = response.data;

        if (access_token) {
          localStorage.setItem('token', access_token);
          api.defaults.headers.Authorization = `Bearer ${access_token}`;
          originalRequest.headers.Authorization = `Bearer ${access_token}`;

          return api(originalRequest);
        }
      } catch (refreshError) {
        store.dispatch(logout());
        toast.error('Session expired. Please login again.');
        return Promise.reject(refreshError);
      }
    }

    // Handle other errors
    if (error.response) {
      const message = error.response.data?.detail || 
                     error.response.data?.message || 
                     'An error occurred';
      toast.error(message);
    } else if (error.request) {
      toast.error('Network error. Please check your connection.');
    } else {
      toast.error('An unexpected error occurred.');
    }

    return Promise.reject(error);
  }
);

// Error handling utility
const handleApiError = (error, customMessage = '') => {
  console.error('API Error:', error);

  const errorMessage = error.response?.data?.detail || 
                      error.response?.data?.message ||
                      customMessage ||
                      'An unexpected error occurred';

  toast.error(errorMessage);
  return Promise.reject(new Error(errorMessage));
};

// Single export statement for all exports
export { api as default, handleApiError, API_ENDPOINTS };

2. Related Components:

   ```

   /src/components/operators/OperatorDetailModal.jsx
// File: /src/components/operators/OperatorDetailModal.jsx
import React, { useState, useEffect } from 'react';
import { Modal, Button, Form, Row, Col } from 'react-bootstrap';
import { toast } from 'react-toastify';
import operatorService from '../../services/operatorService';

const OperatorDetailModal = ({ show, onHide, operator = null, onOperatorAdded, onOperatorUpdated }) => {
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    operator_name: '',
    company_code: '',
    address_1: '',
    address_2: '',
    post_code: '',
    zipcode: '',
    phone_no_1: '',
    phone_no_2: '',
    state: '',
    country: ''
  });

  useEffect(() => {
    if (operator) {
      setFormData({
        operator_name: operator.operator_name || '',
        company_code: operator.company_code || '',
        address_1: operator.address_1 || '',
        address_2: operator.address_2 || '',
        post_code: operator.post_code || '',
        zipcode: operator.zipcode || '',
        phone_no_1: operator.phone_no_1 || '',
        phone_no_2: operator.phone_no_2 || '',
        state: operator.state || '',
        country: operator.country || ''
      });
    } else {
      setFormData({
        operator_name: '',
        company_code: '',
        address_1: '',
        address_2: '',
        post_code: '',
        zipcode: '',
        phone_no_1: '',
        phone_no_2: '',
        state: '',
        country: ''
      });
    }
  }, [operator]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      setLoading(true);
      let response;
      
      if (operator) {
        response = await operatorService.updateOperator(operator.id, formData);
        toast.success('Operator updated successfully');
        onOperatorUpdated?.(response);
      } else {
        response = await operatorService.createOperator(formData);
        toast.success('Operator added successfully');
        onOperatorAdded?.(response);
      }
      onHide();
    } catch (error) {
      console.error('Error saving operator:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal show={show} onHide={onHide} size="lg">
      <Modal.Header closeButton>
        <Modal.Title>{operator ? 'Edit Operator' : 'Add New Operator'}</Modal.Title>
      </Modal.Header>
      <Form onSubmit={handleSubmit}>
        <Modal.Body>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Operator Name <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="text"
                  name="operator_name"
                  value={formData.operator_name}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Company Code</Form.Label>
                <Form.Control
                  type="text"
                  name="company_code"
                  value={formData.company_code}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Address Line 1</Form.Label>
                <Form.Control
                  type="text"
                  name="address_1"
                  value={formData.address_1}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Address Line 2</Form.Label>
                <Form.Control
                  type="text"
                  name="address_2"
                  value={formData.address_2}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>State</Form.Label>
                <Form.Control
                  type="text"
                  name="state"
                  value={formData.state}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Country <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="text"
                  name="country"
                  value={formData.country}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
          </Row>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Post Code</Form.Label>
                <Form.Control
                  type="text"
                  name="post_code"
                  value={formData.post_code}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Zip Code</Form.Label>
                <Form.Control
                  type="text"
                  name="zipcode"
                  value={formData.zipcode}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Phone Number 1</Form.Label>
                <Form.Control
                  type="text"
                  name="phone_no_1"
                  value={formData.phone_no_1}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Phone Number 2</Form.Label>
                <Form.Control
                  type="text"
                  name="phone_no_2"
                  value={formData.phone_no_2}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={onHide}>
            Cancel
          </Button>
          <Button variant="primary" type="submit" disabled={loading}>
            {loading ? (operator ? 'Updating...' : 'Adding...') : (operator ? 'Update' : 'Add')} Operator
          </Button>
        </Modal.Footer>
      </Form>
    </Modal>
  );
};

export default OperatorDetailModal;
   /src/components/purchaseOrders/PurchaseOrderModal.jsx

 // src/components/purchaseOrders/PurchaseOrderModal.jsx
import React, { useState } from 'react';
import { Modal, Form, Button, Row, Col } from 'react-bootstrap';
import { toast } from 'react-toastify';
import purchaseOrderService from '../../services/purchaseOrderService';

const PurchaseOrderModal = ({ show, onHide, onPurchaseOrderCreated, wellId }) => {
  const [formData, setFormData] = useState({
    well_id: wellId || '',
    po_number: '',
    contract_no: '',
    vendor_no: '',
    DRSS_no: '',
    po_date: '',
    supplier_name: '',
    supplier_address1: '',
    supplier_address2: '',
    county: '',
    country: '',
    supplier_contact: '',
    supplier_contact_information: '',
    buyer_name: '',
    buyer_address1: '',
    buyer_address_2: '',
    buyer_contact_information: '',
    delievry_address1: '',
    delivery_address2: '',
    delievry_postcode: '',
    delivery_zipcode: '',
    payment_terms: '',
    shipping_terms: ''
  });

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await purchaseOrderService.createPurchaseOrder(formData);
      toast.success('Purchase order created successfully');
      onPurchaseOrderCreated(response);
      onHide();
    } catch (error) {
      toast.error(error.message || 'Failed to create purchase order');
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  return (
    <Modal show={show} onHide={onHide} size="lg">
      <Modal.Header closeButton>
        <Modal.Title>Create Purchase Order</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <Form onSubmit={handleSubmit}>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>PO Number <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="text"
                  name="po_number"
                  value={formData.po_number}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Contract Number</Form.Label>
                <Form.Control
                  type="text"
                  name="contract_no"
                  value={formData.contract_no}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Vendor Number</Form.Label>
                <Form.Control
                  type="text"
                  name="vendor_no"
                  value={formData.vendor_no}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>DRSS Number</Form.Label>
                <Form.Control
                  type="text"
                  name="DRSS_no"
                  value={formData.DRSS_no}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>PO Date <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="date"
                  name="po_date"
                  value={formData.po_date}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
          </Row>

          <h5 className="mt-4">Supplier Information</h5>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Supplier Name <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="text"
                  name="supplier_name"
                  value={formData.supplier_name}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Supplier Contact</Form.Label>
                <Form.Control
                  type="text"
                  name="supplier_contact"
                  value={formData.supplier_contact}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Supplier Address 1</Form.Label>
                <Form.Control
                  type="text"
                  name="supplier_address1"
                  value={formData.supplier_address1}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Supplier Address 2</Form.Label>
                <Form.Control
                  type="text"
                  name="supplier_address2"
                  value={formData.supplier_address2}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>County</Form.Label>
                <Form.Control
                  type="text"
                  name="county"
                  value={formData.county}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Country</Form.Label>
                <Form.Control
                  type="text"
                  name="country"
                  value={formData.country}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <h5 className="mt-4">Buyer Information</h5>
          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Buyer Name <span className="text-danger">*</span></Form.Label>
                <Form.Control
                  type="text"
                  name="buyer_name"
                  value={formData.buyer_name}
                  onChange={handleChange}
                  required
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Buyer Contact Information</Form.Label>
                <Form.Control
                  type="text"
                  name="buyer_contact_information"
                  value={formData.buyer_contact_information}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Buyer Address 1</Form.Label>
                <Form.Control
                  type="text"
                  name="buyer_address1"
                  value={formData.buyer_address1}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Buyer Address 2</Form.Label>
                <Form.Control
                  type="text"
                  name="buyer_address_2"
                  value={formData.buyer_address_2}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <h5 className="mt-4">Delivery Information</h5>
          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Delivery Address 1</Form.Label>
                <Form.Control
                  type="text"
                  name="delievry_address1"
                  value={formData.delievry_address1}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={12}>
              <Form.Group className="mb-3">
                <Form.Label>Delivery Address 2</Form.Label>
                <Form.Control
                  type="text"
                  name="delivery_address2"
                  value={formData.delivery_address2}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Delivery Postcode</Form.Label>
                <Form.Control
                  type="text"
                  name="delievry_postcode"
                  value={formData.delievry_postcode}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Delivery Zipcode</Form.Label>
                <Form.Control
                  type="text"
                  name="delivery_zipcode"
                  value={formData.delivery_zipcode}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>

          <Row>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Payment Terms</Form.Label>
                <Form.Control
                  type="text"
                  name="payment_terms"
                  value={formData.payment_terms}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
            <Col md={6}>
              <Form.Group className="mb-3">
                <Form.Label>Shipping Terms</Form.Label>
                <Form.Control
                  type="text"
                  name="shipping_terms"
                  value={formData.shipping_terms}
                  onChange={handleChange}
                />
              </Form.Group>
            </Col>
          </Row>
        </Form>
      </Modal.Body>
      <Modal.Footer>
        <Button variant="secondary" onClick={onHide}>
          Cancel
        </Button>
        <Button variant="primary" onClick={handleSubmit}>
          Create Purchase Order
        </Button>
      </Modal.Footer>
    </Modal>
  );
};

export default PurchaseOrderModal;

3. Type Definitions (if any):

   ```

   /src/types/

     - job.types.ts

     - operator.types.ts

   ```