# app/api/v1/endpoints/auth.py
from datetime import timedelta
from typing import Any
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from pydantic import BaseModel

from app.core.auth import (
    authenticate_user,
    create_access_token,
    get_current_user,
    verify_password
)
from app.core.security import (
    generate_verification_token,
    send_verification_email,
    validate_password
)
from app.schemas import Token, UserCreate, UserResponse, User
from app.core.config import settings
from app.crud import user
from app.database import get_db
from app.models.auth import User as DBUser

router = APIRouter()

class LoginRequest(BaseModel):
    username: str
    password: str

@router.post("/auth/login", response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
) -> Any:
    print("Entered main login procedure!") 
    user_obj = await authenticate_user(db, form_data.username, form_data.password)
    if not user_obj:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": form_data.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/auth/login_v2")
def login(request: LoginRequest, db: Session = Depends(get_db)):
    # dummy_user = {
    #     "username": "testuser",
    #     "password": "Password123!"
    # }
     
    # Check if provided credentials match dummy credentials
    
    # if request.username == dummy_user["username"] and request.password == dummy_user["password"]:
    #     return {"access_token": "dummyToken", "user": dummy_user}
    
    print("get test user credentials")  
    user = db.query(DBUser).filter(DBUser.username == request.username).first()
    if not user or not verify_password(request.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": request.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

    #     print("test user credentials failed")  
    #     raise HTTPException(status_code=401, detail="Invalid credentials")
    # access_token = create_access_token(data={"sub": user.username})
    # print("access credentials granted sucessfully!")  
    # return {"access_token": access_token, "user": user}


@router.post("/auth/register", response_model=UserResponse)
async def register_user(
    *,
    db: Session = Depends(get_db),
    user_in: UserCreate
) -> Any:
    if not validate_password(user_in.password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password does not meet requirements"
        )
    existing_user = user.get_by_email(db, email=user_in.email)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    verification_token = generate_verification_token()
    new_user = user.create(db, obj_in=user_in)

    # Send verification email
    email_sent = await send_verification_email(user_in.email, verification_token)
    if not email_sent:
        user.remove(db, id=new_user.id)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to send verification email"
        )

    return {
        "email": new_user.email,
        "message": "Registration successful. Please check your email to verify your account."
    }


@router.get("/auth/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    email = current_user.get("email")
    if not email or "@" not in email:
        email = "placeholder@example.com"  # Set a default valid email address or handle accordingly

    return {
        "email": email,
        "full_name": current_user.get("full_name", "Unknown"),  # Add other fields as needed
        "message": "Current user information retrieved successfully"
    }


# @router.get("/auth/me", response_model=UserResponse)
# async def read_users_me(
#     current_user: User = Depends(get_current_user)
# ) -> Any:
#     return {
#         "email": current_user.email,
#         "message": "Current user information retrieved successfully"
#     }

# @router.post("/auth/login_v2")
# def login(request: LoginRequest, db: Session = Depends(get_db)):
#     user = db.query(DBUser).filter(DBUser.username == request.username).first()
#     if not user or not verify_password(request.password):
#         raise HTTPException(status_code=401, detail="Invalid credentials")
#     access_token = create_access_token(data={"sub": user.username})
#     return {"access_token": access_token, "user": user}


# app/api/v1/endpoints/password_reset.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Any
from datetime import datetime, timedelta
import secrets
import bcrypt
from app.core.security import get_password_hash
from app.core.email import EmailService
from app.database import get_db
from app.models.auth import User, PasswordReset
from app.schemas.password_reset import (
    PasswordResetRequest,
    PasswordResetVerify,
    PasswordResetExecute,
    PasswordResetResponse
)
from app.core.config import settings

router = APIRouter()

def generate_reset_token() -> str:
    """Generate a secure token for password reset"""
    return secrets.token_urlsafe(32)

@router.post("/request-reset", response_model=PasswordResetResponse)
async def request_password_reset(
    request: PasswordResetRequest,
    db: Session = Depends(get_db)
) -> Any:
    """
    Request a password reset email
    """
    user = db.query(User).filter(User.email == request.email).first()

    # Don't reveal if email exists or not
    if not user:
        return {
            "message": "If your email is registered, you will receive a password reset link",
            "success": True
        }

    # Delete any existing non-used reset tokens for this user
    db.query(PasswordReset).filter(
        PasswordReset.user_id == user.id,
        PasswordReset.is_used_(False)
    ).delete()

    # Create new reset token
    token = generate_reset_token()
    expires_at = datetime.utcnow() + timedelta(hours=1)
    
    reset_entry = PasswordReset(
        user_id=user.id,
        token=token,
        expires_at=expires_at
    )
    
    db.add(reset_entry)
    db.commit()
    db.refresh(reset_entry)

    # Generate reset link
    reset_link = f"{settings.FRONTEND_URL}/reset-password/{token}"
    
    # Send email asynchronously
    try:
        await EmailService.send_reset_email(user.email, reset_link)
    except Exception as e:
        # Log the error but don't reveal it to the user
        print(f"Failed to send reset email: {e}")
        db.delete(reset_entry)
        db.commit()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to send reset email"
        )

    return {
        "message": "If your email is registered, you will receive a password reset link",
        "success": True
    }

@router.get("/verify-token/{token}", response_model=PasswordResetResponse)
async def verify_reset_token(
    token: str,
    db: Session = Depends(get_db)
) -> Any:
    """
    Verify if a reset token is valid
    """
    reset_entry = db.query(PasswordReset).filter(
        PasswordReset.token == token,
        PasswordReset.is_used == False,
        PasswordReset.expires_at > datetime.utcnow()
    ).first()

    if not reset_entry:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    return {
        "message": "Token is valid",
        "success": True
    }

@router.post("/reset-password", response_model=PasswordResetResponse)
async def reset_password(
    reset_data: PasswordResetExecute,
    db: Session = Depends(get_db)
) -> Any:
    """
    Reset password using the reset token
    """
    reset_entry = db.query(PasswordReset).filter(
        PasswordReset.token == reset_data.token,
        PasswordReset.is_used_(False),
        PasswordReset.expires_at > datetime.utcnow()
    ).first()

    if not reset_entry:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    user = db.query(User).filter(User.id == reset_entry.user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Update password with new hashed password
    user.hashed_password = get_password_hash(reset_data.new_password)
    
    # Mark token as used
    reset_entry.is_used = True
    reset_entry.used_at = datetime.utcnow()

    # Optionally, invalidate all user sessions here
    # This depends on your session management implementation

    db.commit()

    return {
        "message": "Password has been reset successfully",
        "success": True
    }

# app/models/auth.py
from sqlalchemy import Boolean, Column, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import uuid
from app.database import Base

def generate_uuid():
    return str(uuid.uuid4())

def utcnow():
    return datetime.now(timezone.utc)

class User(Base):
    __tablename__ = "user"

    id = Column(String, primary_key=True, default=generate_uuid)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)
    verification_token = Column(String, unique=True, nullable=True)
    created_at = Column(DateTime, default=utcnow)
    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)

    # Relationships
    password_resets = relationship("PasswordReset", back_populates="user")
    sessions = relationship("UserSession", back_populates="user")

    def __repr__(self):
        return f"<User {self.email}>"

class PasswordReset(Base):
    __tablename__ = "password_reset"

    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("user.id"), nullable=False)  # Fixed FK reference
    token = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)
    created_at = Column(DateTime, default=utcnow)
    expires_at = Column(DateTime, nullable=False)

    # relationship
    user = relationship("User", back_populates="password_resets")

    def __repr__(self):
        return f"<PasswordReset {self.token}>"

class UserSession(Base):
    __tablename__ = "user_session"

    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("user.id"), nullable=False)  # Fixed FK reference
    access_token = Column(String, unique=True, nullable=False)
    refresh_token = Column(String, unique=True, nullable=True)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=utcnow)
    last_activity = Column(DateTime, default=utcnow, onupdate=utcnow)
    is_active = Column(Boolean, default=True)
    device_info = Column(String, nullable=True)
    ip_address = Column(String, nullable=True)


from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional
from datetime import datetime
from uuid import UUID

# Token schemas
class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

class TokenData(BaseModel):
    email: Optional[str] = None
    exp: Optional[datetime] = None

# User schemas
class UserBase(BaseModel):
    email: EmailStr
    full_name: Optional[str] = None
    is_active: bool = True
    username: Optional[str] = Field(None, min_length=3, max_length=50)

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)
    username: str = Field(..., min_length=3, max_length=50)  # Required for create

class UserUpdate(UserBase):
    password: Optional[str] = None
    email: Optional[EmailStr] = None
    username: Optional[str] = Field(None, min_length=3, max_length=50)

class User(UserBase):
    id: UUID
    is_verified: bool
    username: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)

class UserInDB(User):
    hashed_password: str

class UserResponse(BaseModel):
    email: EmailStr
    message: Optional[str] = None

# Password reset schemas
class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetVerify(BaseModel):
    token: str

class PasswordResetExecute(BaseModel):
    token: str
    new_password: str = Field(..., min_length=8)

class PasswordResetResponse(BaseModel):
    message: str
    success: bool = True

# Session schemas
class UserSessionBase(BaseModel):
    user_id: UUID
    access_token: str
    expires_at: datetime
    device_info: Optional[str] = None
    ip_address: Optional[str] = None

class UserSessionCreate(UserSessionBase):
    refresh_token: Optional[str] = None

class UserSession(UserSessionBase):
    id: UUID
    refresh_token: Optional[str] = None
    created_at: datetime
    last_activity: datetime
    is_active: bool

    model_config = ConfigDict(from_attributes=True)

# Extended Password Reset schemas for internal use
class PasswordResetBase(BaseModel):
    user_id: UUID
    token: str
    expires_at: datetime

class PasswordResetCreate(PasswordResetBase):
    pass

class PasswordReset(PasswordResetBase):
    id: UUID
    created_at: datetime
    is_used: bool

    model_config = ConfigDict(from_attributes=True)
    # relationship
    user = relationship("User", back_populates="sessions")

    def __repr__(self):
        return f"<UserSession {self.id}>"


# app/schemas/password_reset.py
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime

class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetVerify(BaseModel):
    token: str

class PasswordResetExecute(BaseModel):
    token: str
    new_password: str = Field(..., min_length=8)

class PasswordResetResponse(BaseModel):
    message: str
    success: bool

# app/core/auth.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.core.config import settings
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from pydantic import EmailStr

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    # Here you would typically query your database to get the user
    # For now, we'll return the email as the user identifier
    return {"email": email}

# async def authenticate_user(db, email: EmailStr, password: str):
#     # This is a placeholder - you'll need to implement actual database queries
#     user = None  # await get_user_by_email(email)
#     if not user:
#         return False
#     if not verify_password(password, user.hashed_password):
#         return False
#     return user
from sqlalchemy.orm import Session
from fastapi import HTTPException, status
from app.models.auth import User
from app.core.auth import verify_password
# from pydantic import EmailStr

async def authenticate_user(db: Session, username: str, password: str):
    try:
        # Query the database for the user by email
        user = db.query(User).filter(User.username == username).first()
        
        if not user:
            return False
        
        # Verify the password
        if not verify_password(password, user.hashed_password):
            return False
        
        return user
    
    except Exception as e:
        print(f"An error occurred during authentication: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Authentication failed due to an internal error."
        )


# app/core/security.py
from datetime import datetime, timedelta
import hashlib
import os
from typing import Optional
from fastapi import HTTPException, status
from app.core.config import settings
from app.core.email import EmailService
from pydantic import EmailStr
import secrets
import string

class SecurityUtils:
    @staticmethod
    def generate_token(length: int = 32) -> str:
        """Generate a secure random token"""
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))

    @staticmethod
    def validate_password_strength(password: str) -> bool:
        """
        Validate password strength
        Must have:
        - At least 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        """
        if len(password) < 8:
            return False
        if not any(c.isupper() for c in password):
            return False
        if not any(c.islower() for c in password):
            return False
        if not any(c.isdigit() for c in password):
            return False
        return True

    @staticmethod
    def validate_token_expiry(created_at: datetime, expire_hours: int = 24) -> bool:
        """Check if a token has expired"""
        expiry_time = created_at + timedelta(hours=expire_hours)
        return datetime.utcnow() <= expiry_time
    
    @staticmethod
    def get_password_hash(password: str) -> str:
        """Hash a password with a randomly generated salt"""
        salt = os.urandom(16)
        hashed_password = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
        return salt + hashed_password

class TokenService:
    def __init__(self):
        self.security_utils = SecurityUtils()
        self.email_service = EmailService()

    def generate_password_reset_token(self) -> str:
        """Generate a token for password reset"""
        return self.security_utils.generate_token(32)

    def generate_verification_token(self) -> str:
        """Generate a token for email verification"""
        return self.security_utils.generate_token(32)

    async def send_password_reset_email(self, email: EmailStr, reset_token: str) -> bool:
        """Send password reset email"""
        reset_link = f"{settings.FRONTEND_URL}/reset-password?token={reset_token}"
        return await self.email_service.send_reset_email(email, reset_link)

    async def send_verification_email(self, email: EmailStr, verification_token: str) -> bool:
        """Send email verification email"""
        verification_link = f"{settings.FRONTEND_URL}/verify-email?token={verification_token}"
        return await self.email_service.send_verification_email(email, verification_link)

# Create instances for export
security_utils = SecurityUtils()
token_service = TokenService()

# Export commonly used functions
generate_password_reset_token = token_service.generate_password_reset_token
generate_verification_token = token_service.generate_verification_token
send_password_reset_email = token_service.send_password_reset_email
send_verification_email = token_service.send_verification_email
validate_password = security_utils.validate_password_strength
validate_token_expiry = security_utils.validate_token_expiry
get_password_hash = security_utils.get_password_hash


from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pydantic import EmailStr
from typing import List
from jinja2 import Environment, select_autoescape, PackageLoader
from app.core.config import settings
import os
from pathlib import Path

# Get the absolute path to the templates directory
BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATE_FOLDER = BASE_DIR / "templates"

# Ensure the template directory exists
if not TEMPLATE_FOLDER.exists():
    TEMPLATE_FOLDER.mkdir(parents=True)
if not (TEMPLATE_FOLDER / "email").exists():
    (TEMPLATE_FOLDER / "email").mkdir()

email_conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME,
    MAIL_PASSWORD=settings.MAIL_PASSWORD,
    MAIL_FROM=settings.MAIL_FROM,
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER,
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
    USE_CREDENTIALS=True,
    VALIDATE_CERTS=True,
    TEMPLATE_FOLDER=str(TEMPLATE_FOLDER)
)

class EmailService:
    def __init__(self):
        self.fastmail = FastMail(email_conf)
        self.env = Environment(
            loader=PackageLoader('app', 'templates/email'),
            autoescape=select_autoescape(['html', 'xml'])
        )

    async def send_reset_email(self, email: EmailStr, reset_link: str):
        try:
            template = self.env.get_template('password_reset.html')
            html = template.render(
                reset_link=reset_link,
                valid_hours=1
            )

            message = MessageSchema(
                subject="Reset Your FieldTrax Password",
                recipients=[email],
                body=html,
                subtype="html"
            )

            await self.fastmail.send_message(message)
            return True
        except Exception as e:
            print(f"Error sending reset email: {str(e)}")
            return False

    async def send_verification_email(self, email: EmailStr, verification_link: str):
        try:
            template = self.env.get_template('email_verification.html')
            html = template.render(
                verification_link=verification_link
            )

            message = MessageSchema(
                subject="Verify Your FieldTrax Email",
                recipients=[email],
                body=html,
                subtype="html"
            )

            await self.fastmail.send_message(message)
            return True
        except Exception as e:
            print(f"Error sending verification email: {str(e)}")
            return False

    async def send_notification(self, recipients: List[EmailStr], subject: str, body: str):
        try:
            message = MessageSchema(
                subject=subject,
                recipients=recipients,
                body=body,
                subtype="html"
            )

            await self.fastmail.send_message(message)
            return True
        except Exception as e:
            print(f"Error sending notification: {str(e)}")
            return False

# Create a global instance
email_service = EmailService()


//src/components/auth/LoginForm.jsx
import React, { useState } from 'react';
import { useNavigate, useLocation, Link } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { httpClient } from '../../lib/api/httpClient';
import { Form, Button, Card, Container, Alert, Spinner } from 'react-bootstrap';

const LoginForm = () => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const navigate = useNavigate();
    const location = useLocation();
    const { login } = useAuth();

    const from = location.state?.from?.pathname || '/dashboard';

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setIsLoading(true);
        
        try {
            console.log('Attempting login with credentials...');
            
            // First try the login_v2 endpoint which expects JSON
            try {
                const loginResponse = await httpClient.post('api/v1/auth/login', {
                    username,
                    password
                }, {
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Login response:', loginResponse);

                if (loginResponse.data?.access_token) {
                    // Store the token
                    localStorage.setItem('auth_token', loginResponse.data.access_token);
                    
                    // Set auth header for subsequent requests
                    httpClient.defaults.headers.common['Authorization'] = 
                        `Bearer ${loginResponse.data.access_token}`;

                    try {
                        // Get user data using the token
                        const userResponse = await httpClient.get('/api/v1/auth/me');
                        console.log('User data:', userResponse.data);

                        // Call login with both token and user data
                        await login(loginResponse.data.access_token, userResponse.data);

                        console.log('Login successful, redirecting to:', from);
                        navigate(from, { replace: true });
                    } catch (userError) {
                        console.error('Error fetching user data:', userError);
                        throw new Error('Failed to get user data after login');
                    }
                }
            } catch (v2Error) {
                console.log('V2 login failed, trying OAuth endpoint...');
                
                // If login_v2 fails, try the OAuth endpoint
                const formData = new URLSearchParams();
                formData.append('username', username);
                formData.append('password', password);
                formData.append('grant_type', 'password');

                const oauthResponse = await httpClient.post('/api/v1/auth/login', formData, {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                });

                if (oauthResponse.data?.access_token) {
                    localStorage.setItem('auth_token', oauthResponse.data.access_token);
                    httpClient.defaults.headers.common['Authorization'] = 
                        `Bearer ${oauthResponse.data.access_token}`;

                    const userResponse = await httpClient.get('/api/v1/auth/me');
                    await login(oauthResponse.data.access_token, userResponse.data);
                    navigate(from, { replace: true });
                }
            }
        } catch (err) {
            console.error('Login error:', err);
            console.error('Error response:', err.response);
            
            let errorMessage = 'Login failed. ';
            if (err.response?.data?.detail) {
                errorMessage += err.response.data.detail;
            } else if (err.response?.status === 401) {
                errorMessage += 'Incorrect username or password.';
            } else if (err.response?.status === 422) {
                errorMessage += 'Please check your input and try again.';
            } else {
                errorMessage += 'An unexpected error occurred.';
            }
            
            setError(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container className="vh-100 d-flex align-items-center justify-content-center">
            <Card className="p-4 shadow-sm" style={{ maxWidth: '400px', width: '100%' }}>
                <Card.Body>
                    <h2 className="text-center mb-4">Login to FieldTrax</h2>
                    
                    {error && (
                        <Alert variant="danger" dismissible onClose={() => setError('')}>
                            {error}
                        </Alert>
                    )}

                    <Form onSubmit={handleSubmit}>
                        <Form.Group className="mb-3">
                            <Form.Label>Username</Form.Label>
                            <Form.Control
                                type="text"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                required
                                disabled={isLoading}
                                autoComplete="username"
                                placeholder="Enter your username"
                            />
                        </Form.Group>

                        <Form.Group className="mb-4">
                            <Form.Label>Password</Form.Label>
                            <Form.Control
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                disabled={isLoading}
                                autoComplete="current-password"
                                placeholder="Enter your password"
                            />
                        </Form.Group>

                        <Button
                            type="submit"
                            className="w-100 mb-3"
                            variant="primary"
                            disabled={isLoading}
                        >
                            {isLoading ? (
                                <>
                                    <Spinner
                                        as="span"
                                        animation="border"
                                        size="sm"
                                        role="status"
                                        aria-hidden="true"
                                        className="me-2"
                                    />
                                    Logging in...
                                </>
                            ) : (
                                'Login'
                            )}
                        </Button>

                        <div className="text-center">
                            <Link to="/forgot-password" className="text-decoration-none">
                                Forgot Password?
                            </Link>
                        </div>
                    </Form>
                </Card.Body>
            </Card>
        </Container>
    );
};

export default LoginForm;

// src/components/auth/ForgotPasswordForm.jsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { Container, Row, Col, Card, Form, Button, Alert, Spinner } from 'react-bootstrap';
import { httpClient } from '../../lib/api/httpClient';

function ForgotPasswordForm() {
    const [email, setEmail] = useState('');
    const [status, setStatus] = useState({ type: null, message: '' });
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setStatus({ type: null, message: '' });

        try {
            const response = await httpClient.post('/api/v1/auth/forgot-password', {
                email
            });

            setStatus({
                type: 'success',
                message: 'Password reset instructions have been sent to your email.'
            });
            setEmail('');
        } catch (error) {
            console.error('Password reset error:', error);
            setStatus({
                type: 'error',
                message: error.response?.data?.detail || 'Failed to send reset email. Please try again.'
            });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container fluid className="vh-100 bg-light">
            <Row className="h-100 align-items-center justify-content-center">
                <Col xs={12} sm={8} md={6} lg={4}>
                    <Card className="shadow-sm">
                        <Card.Body className="p-4">
                            <div className="text-center mb-4">
                                <h2>Reset Password</h2>
                                <p className="text-muted">
                                    Enter your email address and we'll send you instructions.
                                </p>
                            </div>

                            {status.message && (
                                <Alert variant={status.type === 'success' ? 'success' : 'danger'}>
                                    {status.message}
                                </Alert>
                            )}

                            <Form onSubmit={handleSubmit}>
                                <Form.Group className="mb-3">
                                    <Form.Label>Email Address</Form.Label>
                                    <Form.Control
                                        type="email"
                                        value={email}
                                        onChange={(e) => setEmail(e.target.value)}
                                        required
                                        autoComplete="email"
                                        placeholder="Enter your email"
                                        disabled={isLoading}
                                    />
                                </Form.Group>

                                <Button
                                    type="submit"
                                    variant="primary"
                                    className="w-100 mb-3"
                                    disabled={isLoading}
                                >
                                    {isLoading ? (
                                        <>
                                            <Spinner
                                                as="span"
                                                animation="border"
                                                size="sm"
                                                role="status"
                                                aria-hidden="true"
                                                className="me-2"
                                            />
                                            Sending...
                                        </>
                                    ) : (
                                        'Send Reset Instructions'
                                    )}
                                </Button>

                                <div className="text-center">
                                    <Link to="/login" className="text-decoration-none">
                                        Back to Login
                                    </Link>
                                </div>
                            </Form>
                        </Card.Body>
                    </Card>
                </Col>
            </Row>
        </Container>
    );
}

export default ForgotPasswordForm;


//src/components/auth/ResetPasswordForm.jsx
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { passwordService } from '../../lib/auth/passwordService';

const styles = {
    container: {
        maxWidth: '28rem',
        margin: '0 auto',
        padding: '1.5rem',
        backgroundColor: 'white',
        borderRadius: '0.5rem',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
    },
    title: {
        fontSize: '1.5rem',
        fontWeight: 'bold',
        marginBottom: '1.5rem'
    },
    form: {
        display: 'flex',
        flexDirection: 'column',
        gap: '1rem'
    },
    error: {
        marginBottom: '1rem',
        padding: '0.75rem',
        backgroundColor: '#fee2e2',
        color: '#dc2626',
        borderRadius: '0.375rem'
    },
    successContainer: {
        textAlign: 'center',
        padding: '1.5rem',
        backgroundColor: '#f0fdf4',
        borderRadius: '0.5rem'
    },
    successTitle: {
        fontSize: '1.25rem',
        fontWeight: '600',
        color: '#065f46'
    },
    successMessage: {
        marginTop: '0.5rem',
        color: '#10b981'
    },
    validationError: {
        backgroundColor: '#fef3c7',
        border: '1px solid #f59e0b',
        color: '#92400e',
        padding: '0.75rem',
        borderRadius: '0.375rem',
        marginBottom: '1rem'
    },
    label: {
        display: 'block',
        fontSize: '0.875rem',
        fontWeight: '500',
        color: '#4b5563',
        marginBottom: '0.5rem'
    },
    input: {
        width: '100%',
        padding: '0.5rem',
        borderRadius: '0.375rem',
        border: '1px solid #d1d5db',
        outline: 'none'
    },
    button: {
        width: '100%',
        display: 'flex',
        justifyContent: 'center',
        padding: '0.5rem',
        borderRadius: '0.375rem',
        border: 'none',
        fontSize: '0.875rem',
        fontWeight: '500',
        color: 'white',
        backgroundColor: '#2563eb',
        cursor: 'pointer'
    },
    spinnerContainer: {
        textAlign: 'center',
        padding: '1.5rem'
    },
    spinner: {
        animation: 'spin 1s linear infinite',
        height: '2rem',
        width: '2rem',
        borderBottom: '2px solid #3b82f6',
        borderRadius: '50%',
        margin: '0 auto'
    },
    spinnerText: {
        marginTop: '0.5rem'
    }
};

export const ResetPasswordForm = () => {
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [status, setStatus] = useState('verifying'); // verifying, ready, loading, success, error
    const [error, setError] = useState('');
    const [validationErrors, setValidationErrors] = useState([]);
    const { token } = useParams();
    const navigate = useNavigate();

    useEffect(() => {
        const verifyToken = async () => {
            const isValid = await passwordService.verifyResetToken(token);
            setStatus(isValid ? 'ready' : 'error');
            if (!isValid) {
                setError('This password reset link is invalid or has expired.');
            }
        };
        verifyToken();
    }, [token]);

    const validateForm = () => {
        const errors = [];

        // Validate password
        const { isValid, errors: passwordErrors } = passwordService.validatePassword(password);
        if (!isValid) {
            errors.push(...passwordErrors);
        }

        // Check if passwords match
        if (password !== confirmPassword) {
            errors.push('Passwords do not match');
        }

        setValidationErrors(errors);
        return errors.length === 0;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();

        if (!validateForm()) {
            return;
        }

        setStatus('loading');
        setError('');
        try {
            await passwordService.resetPassword(token, password);
            setStatus('success');
            setTimeout(() => {
                navigate('/login');
            }, 3000);
        } catch (error) {
            setError('Failed to reset password. Please try again.');
            setStatus('error');
            console.error('Failed to reset password.', error);
        }
    };

    if (status === 'verifying') {
        return (
            <div style={styles.spinnerContainer}>
                <div style={styles.spinner}></div>
                <p style={styles.spinnerText}>Verifying reset link...</p>
            </div>
        );
    }

    if (status === 'success') {
        return (
            <div style={styles.successContainer}>
                <h2 style={styles.successTitle}>Password Reset Successful</h2>
                <p style={styles.successMessage}>
                    Your password has been reset successfully. You will be redirected to the login page shortly.
                </p>
            </div>
        );
    }

    return (
        <div style={styles.container}>
            <h2 style={styles.title}>Reset Your Password</h2>

            <form onSubmit={handleSubmit} style={styles.form}>
                {error && (
                    <div style={styles.error}>
                        {error}
                    </div>
                )}
                {validationErrors.length > 0 && (
                    <div style={styles.validationError}>
                        <ul>
                            {validationErrors.map((error, index) => (
                                <li key={index}>{error}</li>
                            ))}
                        </ul>
                    </div>
                )}
                <div>
                    <label htmlFor="password" style={styles.label}>
                        New Password
                    </label>
                    <input
                        type="password"
                        id="password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                        style={styles.input}
                    />
                </div>
                <div>
                    <label htmlFor="confirmPassword" style={styles.label}>
                        Confirm New Password
                    </label>
                    <input
                        type="password"
                        id="confirmPassword"
                        value={confirmPassword}
                        onChange={(e) => setConfirmPassword(e.target.value)}
                        required
                        style={styles.input}
                    />
                </div>
                <button
                    type="submit"
                    disabled={status === 'loading'}
                    style={styles.button}
                >
                    {status === 'loading' ? 'Resetting Password...' : 'Reset Password'}
                </button>
            </form>
        </div>
    );
};

/// src/lib/auth/authService.js
import { httpClient } from '@/lib/api/httpClient';
import { config } from '@/config';

class AuthService {
  constructor() {
    this.tokenKey = config.auth.tokenKey;
    this.userKey = config.auth.userKey;
  }

  async login(username, password) {
    try {
      const response = await httpClient.post('/auth/login', {
        username,
        password,
      });

      const { access_token, user } = response.data;
      localStorage.setItem(this.tokenKey, access_token);
      localStorage.setItem(this.userKey, JSON.stringify(user));
      return user;
    } catch (error) {
      console.error('Login failed:', error.response?.data?.detail || error.message);
      throw error;
    }
  }

  async logout() {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.userKey);
    window.location.href = '/login';
  }

  async isAuthenticated() {
    const token = localStorage.getItem(this.tokenKey);
    return !!token;
  }

  async getUser() {
    const userData = localStorage.getItem(this.userKey);
    return userData ? JSON.parse(userData) : null;
  }

  async getToken() {
    return localStorage.getItem(this.tokenKey);
  }
}

export const authService = new AuthService(); 

// src/lib/auth/passwordService.js
import { httpClient } from '@/lib/api/httpClient';

class PasswordService {
  async requestReset(email) {
    try {
      const response = await httpClient.post('/auth/password/reset-request', { 
        email 
      });
      return response.data;
    } catch (error) {
      console.error('Password reset request failed:', error);
      throw error;
    }
  }

  async verifyResetToken(token) {
    try {
      const response = await httpClient.get(`/auth/password/verify-token/${token}`);
      return response.data.valid;
    } catch (error) {
      console.error('Token verification failed:', error);
      return false;
    }
  }

  async resetPassword(token, new_password) {
    try {
      const response = await httpClient.post('/auth/password/reset', {
        token,
        new_password
      });
      return response.data;
    } catch (error) {
      console.error('Password reset failed:', error);
      throw error;
    }
  }

  validatePassword(password) {
    const errors = [];
    
    if (password.length < 8) {
      errors.push('Password must be at least 8 characters long');
    }
    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }
    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }
    if (!/[0-9]/.test(password)) {
      errors.push('Password must contain at least one number');
    }
    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

export const passwordService = new PasswordService();


# app/core/config.py
from typing import List
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import field_validator, Field

class Settings(BaseSettings):
    # API Settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "FieldTrax"
    
    # CORS Settings
    ALLOWED_ORIGINS: List[str] = [
        "http://localhost:3000",  # React development server
        "http://localhost:5173",  # Vite development server
    ]
    
    # Database Settings
    DB_SERVER: str = Field("localhost", description="Database server host")
    DB_PORT: str = Field("1433", description="Database server port")
    DB_USER: str = Field(..., description="Database username")
    DB_PASSWORD: str = Field(..., description="Database password")
    DB_NAME: str = Field(..., description="Database name")
    DB_DRIVER: str = Field("ODBC Driver 17 for SQL Server", description="SQL Server ODBC driver")

    @property
    def DATABASE_URL(self) -> str:
        # Construct database URL with proper encoding of special characters
        return (
            f"mssql+pyodbc://{self.DB_USER}:{self.DB_PASSWORD}@"
            f"{self.DB_SERVER}:{self.DB_PORT}/{self.DB_NAME}"
            f"?driver={self.DB_DRIVER.replace(' ', '+')}"
        )
    
    # JWT Settings
    SECRET_KEY: str = Field(..., description="Secret key for JWT encoding")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Email Settings
    MAIL_USERNAME: str = Field("", description="SMTP username")
    MAIL_PASSWORD: str = Field("", description="SMTP password")
    MAIL_FROM: str = Field("noreply@fieldtrax.com", description="Default from email")
    MAIL_PORT: int = Field(587, description="SMTP port")
    MAIL_SERVER: str = Field("smtp.gmail.com", description="SMTP server")
    MAIL_STARTTLS: bool = Field(True, description="Use STARTTLS")
    MAIL_SSL_TLS: bool = Field(False, description="Use SSL/TLS")
    MAIL_USE_CREDENTIALS: bool = Field(True, description="Use SMTP authentication")
    MAIL_VALIDATE_CERTS: bool = Field(True, description="Validate SSL certificates")
    
    # Frontend URL
    FRONTEND_URL: str = Field("http://localhost:3000", description="Frontend application URL")

    # Additional Settings
    DEBUG: bool = Field(False, description="Debug mode")

    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=True,
        extra="allow"
    )

settings = Settings()

# app/database.py 
from sqlalchemy import create_engine, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings
import logging
import pyodbc
import requests
from dotenv import load_dotenv
import os

load_dotenv()

logger = logging.getLogger(__name__)

def get_connection_string() -> str:
    """Get the database connection string with proper error handling"""
    try:
        return settings.DATABASE_URL
    except Exception as e:
        logger.error(f"Error constructing database URL: {str(e)}")
        raise

def verify_odbc_driver():
    """Verify that the specified ODBC driver is installed"""
    drivers = [x for x in pyodbc.drivers() if x.endswith(' for SQL Server')]
    if not drivers:
        raise RuntimeError(
            "No SQL Server ODBC drivers found. Please install the Microsoft ODBC Driver for SQL Server."
        )
    if settings.DB_DRIVER not in drivers:
        logger.warning(
            f"Specified driver '{settings.DB_DRIVER}' not found. "
            f"Available drivers: {', '.join(drivers)}"
        )
        raise RuntimeError(f"Specified ODBC driver '{settings.DB_DRIVER}' not found")

def check_internet_connectivity():
    try:
        requests.get('http://www.google.com', timeout=5)
        return True
    except requests.ConnectionError:
        return False

def create_db_engine():
    """Create database engine with proper error handling"""
    try:
        # Verify ODBC driver first if online
        if check_internet_connectivity():
            verify_odbc_driver()
            connection_string = f"mssql+pyodbc://{os.getenv('DB_USER')}:{os.getenv('DB_PASSWORD')}@{os.getenv('DB_SERVER')}:{os.getenv('DB_PORT')}/{os.getenv('DB_NAME')}?driver={os.getenv('DB_DRIVER')}"
        else:
            connection_string = os.getenv("OFFLINE_DATABASE_URL")
            logger.info(f"Using offline database: {connection_string}")

        # Create engine
        engine = create_engine(
            connection_string,
            echo=settings.DEBUG,
            pool_pre_ping=True,
            pool_recycle=300
        )

        # Test connection
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
            logger.info("Database connection test successful")

        return engine
    except Exception as e:
        logger.error(f"Database connection error: {str(e)}")
        raise

# Create engine and ensure schema creation
try:
    engine = create_db_engine()
    Base = declarative_base()

    # Import all your models here
    from app.models.job.database import Job
    # Add other models similarly

    # Create tables
    Base.metadata.create_all(bind=engine)

    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
except Exception as e:
    logger.error(f"Failed to initialize database: {str(e)}")
    raise

def get_db():
    """Dependency for database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# app/crud/user.py
from typing import Optional, Union, Dict, Any
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
import uuid

from app.crud.base import CRUDBase
from app.models.auth import User as UserDB, PasswordReset as PasswordResetDB
from app.schemas.auth import UserCreate, UserUpdate
from app.core.auth import get_password_hash

class CRUDUser(CRUDBase[UserDB, UserCreate, UserUpdate]):
    def get_by_email(self, db: Session, *, email: str) -> Optional[UserDB]:
        return db.query(UserDB).filter(UserDB.email == email).first()

    def create(self, db: Session, *, obj_in: UserCreate) -> UserDB:
        db_obj = UserDB(
            email=obj_in.email,
            hashed_password=get_password_hash(obj_in.password),
            full_name=obj_in.full_name,
            is_active=True,
            is_verified=False
        )
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def update(
        self,
        db: Session,
        *,
        db_obj: UserDB,
        obj_in: Union[UserUpdate, Dict[str, Any]]
    ) -> UserDB:
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.dict(exclude_unset=True)
        if update_data.get("password"):
            hashed_password = get_password_hash(update_data["password"])
            del update_data["password"]
            update_data["hashed_password"] = hashed_password
        return super().update(db, db_obj=db_obj, obj_in=update_data)

    def verify_email(self, db: Session, *, token: str) -> bool:
        user = db.query(UserDB).filter(UserDB.verification_token == token).first()
        if user and not user.is_verified:
            user.is_verified = True
            user.verification_token = None
            db.commit()
            return True
        return False

    def create_password_reset(
        self, db: Session, *, user_id: uuid.UUID, token: str
    ) -> PasswordResetDB:
        # Expire existing tokens
        db.query(PasswordResetDB).filter(
            PasswordResetDB.user_id == user_id,
            PasswordResetDB.is_used == False
        ).update({"is_used": True})

        reset = PasswordResetDB(
            user_id=user_id,
            token=token,
            expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        db.add(reset)
        db.commit()
        db.refresh(reset)
        return reset

# Create instance for use in API endpoints
user = CRUDUser(UserDB)

# app/templates/email/ 
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Email Verification</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Verify Your Email Address</h2>
        <p>Hello,</p>
        <p>Thank you for registering with FieldTrax. Please verify your email address by clicking the button below:</p>
        <p>
            <a href="{{ verification_link }}" class="button">Verify Email</a>
        </p>
        <p>If you didn't create an account with FieldTrax, you can safely ignore this email.</p>
        <div class="footer">
            <p>This is an automated message, please do not reply to this email.</p>
        </div>
    </div>
</body>
</html>

# app/templates/password_reset.html
<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: #ffffff;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .warning {
            color: #721c24;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Password Reset Request</h2>
        <p>Hello,</p>
        <p>We received a request to reset your password for your FieldTrax account. To proceed with the password reset, click the button below:</p>
        
        <a href="{{ reset_link }}" class="button">Reset Password</a>
        
        <p>This link will expire in {{ valid_hours }} hour.</p>
        
        <div class="warning">
            <p>If you didn't request this password reset, please ignore this email or contact support if you have concerns.</p>
        </div>
        
        <p>Best regards,<br>The FieldTrax Team</p>
    </div>
</body>
</html>

// src/context/AuthContext.jsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import { authService } from '../lib/auth/authService';

// Keep existing context creation
export const AuthContext = createContext(null);

// Keep existing useAuth hook
export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const loadUser = async () => {
            try {
                const userData = await authService.getUser();
                setUser(userData);
            } catch (error) {
                console.error('Failed to load user:', error);
            } finally {
                setLoading(false);
            }
        };
        loadUser();
    }, []);

    const login = async (token, user) => {
        // Maintain existing login logic
        setUser(user);
        console.log('User logged in:', user);
    };

    const logout = async () => {
        try {
            await authService.logout();
            setUser(null);
        } catch (error) {
            console.error('Logout error:', error);
        }
    };

    const value = {
        user,
        setUser,
        isAuthenticated: !!user,
        loading,
        login,
        logout // Add logout to the context value
    };

    // Maintain existing loading display
    if (loading) {
        return <div>Loading...</div>;
    }

    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};

// Keep existing default export
export default AuthProvider;


// src/lib/api/httpClient.js
import axios from 'axios';

const httpClient = axios.create({
  // No need for baseURL as we're using Vite's proxy
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for authentication
httpClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('auth_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Add response interceptor for error handling
httpClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('auth_token');
      localStorage.removeItem('user_data');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export { httpClient };


// src/config/index.js
export const config = {
    apiUrl: import.meta.env.VITE_API_URL,
    apiBase: import.meta.env.VITE_API_BASE,
    wsUrl: import.meta.env.VITE_WS_URL,
    auth: {
      tokenKey: 'auth_token',
      userKey: 'user_data',
    }
  };











